---
layout: post
title: "Data Structure--图应用之最短路径"
date: 2014-03-17 00:42:58 +0800
comments: true
categories: 
---



```c++
  #include <iostream>

using namespace std;
const int MaxLen=20;//设置图最多包含20个顶点
const int MaxDist=9999;//设距离无穷大为9999
//---------------图的定义和初始化-----------------
class Map
{
private:
	int Matrix[MaxLen][MaxLen];//图的邻接矩阵
	int Vexnum;//图的顶点数量

public:
	void SetMatrix(int vnum,int mx[MaxLen][MaxLen]);
	void ShortestPath_DIJ(int v0);//迪杰斯特拉算法求v0到其他顶点的最短路径
};
//设置邻接矩阵
void Map::SetMatrix(int vnum,int mx[MaxLen][MaxLen])
{
	int i,j;
	Vexnum = vnum;//设置图的结点数
	for (i=0; i<MaxLen; i++)//邻接矩阵初始化
		for (j=0; j<MaxLen; j++)
			Matrix[i][j] = MaxDist;//假设各个顶点之间距离为无穷大

	for (i=0; i<Vexnum; i++)//邻接矩阵接受外来参数
		for (j=0; j<Vexnum; j++)
		{
			Matrix[i][j] = mx[i][j];//设置顶点i和j之间的实际距离
			if (i!=j && Matrix[i][j] == 0)//如果顶点i和j不相等，应该把距离设为无穷大
				Matrix[i][j] = MaxDist;
		}
}
//------------迪杰斯特拉算法求v0到其他顶点的最短路径
void Map::ShortestPath_DIJ(int v0)
{
	int i,v,w,min;
	int *dist = new int[Vexnum];
	bool *final = new bool[Vexnum];//在求最短路径过程中，标识每个顶点是否被加入集合

	for (v=0; v<Vexnum; ++v) //初始化final数组的所有值为false,表示所有顶点未加入集合
		final[v] = false;	  

	for (v=0; v<Vexnum; ++v) //初始化dist数组，表示v0到其他顶点的初始距离
		dist[v] = Matrix[v0][v];//从邻接矩阵Matrix中读取第v0行的数据，并分别放入dist数组中
	
	dist[v0] = 0;//顶点到自己本身距离为0
	final[v0] = true;//v0加入集合，开始搜索

	for (i=0; i<Vexnum; i++)//逐个顶点被选中加入集合
	{
		min=MaxDist;//初始化min为距离无穷大
		for (w=0; w<Vexnum; w++)//逐个顶点被选中加入集合
		{
			if (!final[w])//在未加入集合的顶点中，寻找离v0最近的顶点
			{
				if (dist[w]<min) //如果顶点w未加入集合，而且v0到w的距离小于min
				{ 
					v = w;  //则设置v=w,且min等于v0到w的距离
					min = dist[w]; 
				}  
			}	
		}

		final[v] = true;//找出离v0最近的顶点v后，把v加入集合

		for (w=0; w<Vexnum; w++)
		{//更新v0到v再到其他顶点w的距离
			if (!final[w] && (min+Matrix[v][w]<dist[w])) //如果顶点w未加入集合，且v0到v再到顶点w的距离小于v0到w的距离
			{
				dist[w] = min + Matrix[v][w];//则修改v0到w的距离等于v0到v在到顶点的距离
			}
		}
	}
 //搜索完毕
    for(i=0; i<Vexnum; i++) //输出v0到其他顶点的最短距离
        cout<<v0<<'-'<<i<<'-'<<dist[i]<<endl;

	delete []dist;
	delete []final;
}//ShortestPath_DIJ

int main()
{
	int i ,j ,k ,t;
	int vnum,v0;
	int mx[MaxLen][MaxLen];
	Map myMap;
	cin>>t;
	for (k=0; k<t; k++)
	{   //输入图的初始化数据
		for (i=0; i<MaxLen; i++)
			for (j=0; j<MaxLen; j++)
				mx[i][j]=0;
		
		cin>>vnum;

		for (i=0; i<vnum; i++)
			for (j=0; j<vnum; j++)
				cin>>mx[i][j];

		myMap.SetMatrix(vnum,mx);//设置图的邻接矩阵

		cin>>v0;//输入起点
		myMap.ShortestPath_DIJ(v0);//迪杰斯特拉算法求V0到其他顶点的最短路径
	}
	return 0;
}

```